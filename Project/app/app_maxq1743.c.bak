/*
*********************************************************************************************************
*
*	模块名称 : 打印机模块
*	文件名称 : app_maxq1743.c
*	版    本 : V1.0
*	说    明 : 
*
*********************************************************************************************************
*/

#include "app.h"

typedef enum
{
	CESHI = 0x10
}MAXQ1743_CMD_NAME;

typedef enum
{
	LINK_TEST = 0x00,
	STATUS = 0X01
}MAXQ1743_CMD_LIST;

/* 磁头驱动芯片引脚 */
//MAXQ1743_RDY
#define RCC_MAXQ1743_RDY 								(RCC_APB2Periph_GPIOB)
#define GPIO_MAXQ1743_RDY_PORT 					(GPIOB)
#define GPIO_MAXQ1743_RDY_PIN 					(GPIO_Pin_0)

//打印机数据通信，SPI_MOSI、SPI_MISO、SPI_SCK
#define RCC_MAXQ1743_INTERFACE_GPIO					(RCC_APB2Periph_GPIOA)
#define RCC_MAXQ1743_INTERFACE_SPI 					(RCC_APB2Periph_SPI1)
#define GPIO_MAXQ1743_INTERFACE_PORT 				(GPIOA)
#define GPIO_MAXQ1743_INTERFACE_SPI_SCK			(GPIO_Pin_5)
#define GPIO_MAXQ1743_INTERFACE_SPI_MISO		(GPIO_Pin_6)
#define GPIO_MAXQ1743_INTERFACE_SPI_MOSI		(GPIO_Pin_7)

#define MAXQ1743_MOSI_HIGH()	do{	\
	GPIO_SetBits(GPIO_MAXQ1743_SSEL_PORT, GPIO_MAXQ1743_INTERFACE_SPI_MOSI); \
}while(0)

#define MAXQ1743_MOSI_LOW() do{	\
	GPIO_ResetBits(GPIO_MAXQ1743_SSEL_PORT, GPIO_MAXQ1743_INTERFACE_SPI_MOSI); \
}while(0)

#define MAXQ1743_SCK_HIGH()	do{	\
	GPIO_SetBits(GPIO_MAXQ1743_SSEL_PORT, GPIO_MAXQ1743_INTERFACE_SPI_MOSI); \
}while(0)

#define MAXQ1743_SCK_LOW() do{	\
	GPIO_ResetBits(GPIO_MAXQ1743_SSEL_PORT, GPIO_MAXQ1743_INTERFACE_SPI_MOSI); \
}while(0)

/*
*********************************************************************************************************
*	函 数 名: is_detect_ok
*	功能说明: 判断磁头芯片是否RDY
*	形    参: 无
*	返 回 值: 返回值1表示磁头芯片RDY ，0表示无磁头芯片忙碌
*********************************************************************************************************
*/
static uint8_t is_detect_ok(void) 
{
	if ((GPIO_MAXQ1743_RDY_PORT->IDR & GPIO_MAXQ1743_RDY_PIN) == RESET) 
	{
		return 0;
	}
	else
	{
		return 1;
	}
}

/*
*********************************************************************************************************
*	函 数 名: spi_read_write_byte
*	功能说明: 打印测试纸
*	形    参：无
*	返 回 值: 0-表示未发送成功
*********************************************************************************************************
*/
static uint8_t spi_read_write_byte(uint8_t datain)
{
	/* 等待上个数据未发送完毕 */
	while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);

	/* 通过SPI硬件发送1个字节 */
	SPI_I2S_SendData(SPI1, datain);

	/* 等待接收一个字节任务完成 */
	while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);

	/* 返回从SPI总线读到的数据 */
	return SPI_I2S_ReceiveData(SPI1);
}


/*
static uint8_t maxq1743_read_write(uint8_t cmd, uint8_t length, uint8_t *databuf)
{
	uint8_t temp_data = 0;
	uint8_t re_try = 0;
	uint8_t i;
	
	MAXQ1743_SSEL_ON();
	bsp_DelayUS(20);
	
	if(cmd & 0x80)//write
	{
		while(spi_read_write_byte(cmd) != 0xAA)
		{
			re_try++;
			if(re_try>200)
			{
				MAXQ1743_SSEL_OFF();
				return 0x11;
			}
		}
		
		if(spi_read_write_byte(length) == 0x00)
		{
			for(i = 0; i < length; i ++)
			{
				temp_data = spi_read_write_byte(*(databuf + i));
			}
		}
		else
		{
			MAXQ1743_SSEL_OFF();
			return 0x12;
		}
	}
	else //read
	{
		re_try = 0;
		while(spi_read_write_byte(cmd) != 0xAA)
		{
			re_try++;
			if(re_try>200)
			{
				MAXQ1743_SSEL_OFF();
				return 0x21;
			}
		}
		re_try = 0;
		do
		{
			temp_data = spi_read_write_byte(0x00);
			re_try++;
			if(re_try>200)
			{
				MAXQ1743_SSEL_OFF();
				return 0x22;
			}
		}while (temp_data == 0);

		for(i = 0; i < temp_data; i ++)
		{
			*(databuf +i) = spi_read_write_byte(0x00);
		}	
	}
	
	MAXQ1743_SSEL_OFF();
	return temp_data;
}
*/

static uint8_t maxq1743_read_write(uint8_t cmd, uint8_t length, uint8_t *databuf)
{}

/*
*********************************************************************************************************
*	函 数 名: ceshi
*	功能说明: 
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
static void ceshi(uint8_t * databuf)
{
	uint8_t temp_data;
	temp_data = maxq1743_read_write(* databuf, *(databuf + 1), (databuf + 2));
	
	if(temp_data)
	{//test 成功
		Usart1_Txd_Tempdata[0] = 0x00;
		Usart1_Txd_Tempdata[1] = 0x03;
		Usart1_Txd_Tempdata[2] = MAXQ1743;
		Usart1_Txd_Tempdata[3] = temp_data;
		Usart1_Txd_Tempdata[4] = *(databuf + 2);
		USART1_Tx_Chars(Usart1_Txd_Tempdata, 5);		
	}
	else
	{
		Usart1_Txd_Tempdata[0] = 0x00;
		Usart1_Txd_Tempdata[1] = 0x02;
		Usart1_Txd_Tempdata[2] = MAXQ1743 | 0x80;
		Usart1_Txd_Tempdata[3] = 0x30;
		USART1_Tx_Chars(Usart1_Txd_Tempdata, 4);	
	}
}

/*
*********************************************************************************************************
*	函 数 名: ceshi1
*	功能说明: 
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
static void ceshi1(void)
{
	uint8_t temp_data;
	uint8_t databuf[10];
	uint8_t re_try = 0;
	
	MAXQ1743_SSEL_ON();
	bsp_DelayUS(20);

		while(spi_read_write_byte(0x82) != 0xAA)
		{
			re_try++;
			if(re_try>200)
			{
				MAXQ1743_SSEL_OFF();
			}
		}
		
		if(spi_read_write_byte(0x00) == 0x01)
		{
			temp_data = spi_read_write_byte(0x00);
		}
		else
		{
			MAXQ1743_SSEL_OFF();
		}

	MAXQ1743_SSEL_OFF();

	if(temp_data)
	{//test 成功
		Usart1_Txd_Tempdata[0] = 0x00;
		Usart1_Txd_Tempdata[1] = 0x02;
		Usart1_Txd_Tempdata[2] = MAXQ1743;
		Usart1_Txd_Tempdata[3] = temp_data;
		Usart1_Txd_Tempdata[4] = *databuf;
		USART1_Tx_Chars(Usart1_Txd_Tempdata, 5);		
	}
	else
	{
		Usart1_Txd_Tempdata[0] = 0x00;
		Usart1_Txd_Tempdata[1] = 0x02;
		Usart1_Txd_Tempdata[2] = MAXQ1743 | 0x80;
		Usart1_Txd_Tempdata[3] = 0x30;
		USART1_Tx_Chars(Usart1_Txd_Tempdata, 4);	
	}
}

static void spi_send_byte(uint8_t datain)
{
	MAXQ1743_MOSI_LOW
	MAXQ1743_SCK_LOW
	
	
	
}


/*
*********************************************************************************************************
*	函 数 名: maxq1743_Init
*	功能说明: 磁头芯片驱动初始化。包含1.各驱动信号IO初始化  2.SPI初始化
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void maxq1743_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;

	/* MAXQ1743-SPI通信引脚 */
	RCC_APB2PeriphClockCmd(RCC_MAXQ1743_INTERFACE_GPIO, ENABLE);
	GPIO_InitStructure.GPIO_Pin = GPIO_MAXQ1743_INTERFACE_SPI_SCK;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;	//maxa1743支持的最高时钟频率为100K
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT_PP;	//设置为推挽功能
	GPIO_Init(GPIO_MAXQ1743_INTERFACE_PORT, &GPIO_InitStructure);

}

/*
*********************************************************************************************************
*	函 数 名: maxq1743_CMD_DEAL
*	功能说明: 处理磁头相关命令
*	形    参：databuf	：串口接收到的数据包的首字节地址
						length	: 数据包长度
*	返 回 值: 无
*********************************************************************************************************
*/
void maxq1743_CMD_DEAL(uint8_t *databuf, uint16_t length)
{
	switch (*databuf)
	{
		case CESHI:
			//测试命令
			if(*(databuf + 1) == 0x00)
			{
				ceshi(databuf + 2);
			}
			else
			{
				if (length == 2)
				{
					if(*(databuf + 1) == 0x01)
					{
						ceshi1();
					}
					else
					{
						//对象命令参数错误
						Usart1_Txd_Tempdata[0] = 0x00;
						Usart1_Txd_Tempdata[1] = 0x02;
						Usart1_Txd_Tempdata[2] = MAXQ1743 | 0x80;
						Usart1_Txd_Tempdata[3] = 0x21;
						USART1_Tx_Chars(Usart1_Txd_Tempdata, 4);
					}
				}
				else
				{
					//对象命令参数长度错误
					Usart1_Txd_Tempdata[0] = 0x00;
					Usart1_Txd_Tempdata[1] = 0x02;
					Usart1_Txd_Tempdata[2] = MAXQ1743 | 0x80;
					Usart1_Txd_Tempdata[3] = 0x11;
					USART1_Tx_Chars(Usart1_Txd_Tempdata, 4);
				}
			}
			break;
		default :
				//对象不支持该命令
				Usart1_Txd_Tempdata[0] = 0x00;
				Usart1_Txd_Tempdata[1] = 0x02;
				Usart1_Txd_Tempdata[2] = MAXQ1743 | 0x80;
				Usart1_Txd_Tempdata[3] = 0x10;
				USART1_Tx_Chars(Usart1_Txd_Tempdata, 4);
			break;
	}
}

/*
*********************************************************************************************************
*	函 数 名: maxq1743_SERVER_TASK
*	功能说明: 磁头相关服务函数
*	形    参：无
*	返 回 值: 无
*********************************************************************************************************
*/
void maxq1743_SERVER_TASK(void)
{
  static uint32_t sys_time, time_ms = 0, time_add_up = 0;
  const uint32_t work_time_max = 2;
	uint32_t offset_time_ticks = 0;
	uint8_t timeout_flag = 0;
	DISABLE_INT();
	sys_time = Sys_Time;
	ENABLE_INT();
	
	if (time_ms != sys_time)
	{
		if (time_ms < sys_time)
		{
			offset_time_ticks = sys_time - time_ms;
			time_ms = sys_time;
			if (((uint64_t)offset_time_ticks  + (uint64_t)time_add_up) > UINT_LEAST32_MAX)
			{
				timeout_flag = 1;
				time_add_up = 0;
			}
			else if ((offset_time_ticks  + time_add_up) > work_time_max)
			{
				timeout_flag = 1;
				time_add_up = 0;
			}
			else
			{
				time_add_up += offset_time_ticks;
			}
		}
		else
		{
			offset_time_ticks = UINT_LEAST32_MAX + sys_time - time_ms;
			time_ms = sys_time;
			if (((uint64_t)offset_time_ticks  + (uint64_t)time_add_up) > UINT_LEAST32_MAX)
			{
				timeout_flag = 1;
				time_add_up = 0;
			}
			else if ((offset_time_ticks  + time_add_up) > work_time_max)
			{
				timeout_flag = 1;
				time_add_up = 0;
			}
			else
			{
				time_add_up += offset_time_ticks;
			}
		}
		if (timeout_flag == 1)
		{
			timeout_flag = 0;
			
		}
	}
}
